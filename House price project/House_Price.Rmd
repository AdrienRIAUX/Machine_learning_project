---
title: "House price project"
author : "Adrien Riaux"
date : "01/08/2022"
output: rmarkdown::github_document
---

# House price project

```{r}
#Import 
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(coefplot)
```

We have several columns : 
- datesold : date of the property sale
- postcode : postal code of the property
- price : sale price of the property 
- propertyType : unit or house 
- bedrooms : number of bedrooms per property

```{r}
#Read data
df = read.csv("house_price.csv", header = TRUE, sep = ",")
head(df)
```
We can observe that our dataframe contains date, but there store as characters. Moreover, it seems that the propertyType and bedrooms columns are categorical features. To verify that, we observe the number of unique value for these features.

```{r}
#Check unique value of categorical features
for (i in c("propertyType", "bedrooms")) {
  print(unique(df[,i]))
}
```

Well, we have only to possible values for properyType and 6 for bedrooms. Use propertyType as factor would be interesting but we will keep bedrooms as int, because there are an order in this features. Have 3 bedrooms is better than only 2 for example.

So we can now convert propertyType and datesold features into appropriate types.

```{r}
#Convert type
df[, "propertyType"] <- as.factor(df[, "propertyType"])
df[, "datesold"] <- as.Date(df[, "datesold"])

sapply(df, class)
```

```{r}
#Data description
summary(df)
```

We have no null values in the dataframe. Moreover postcode is only 4 digits reference, we don't expect that this data will be useful in this form. We will probably transform it into a categorical class. 

### Exploratory data analysis

```{r}
#Plot density of postcode per propertyType
ggplot(data = df, aes(x = postcode)) + #Add histogram
  geom_histogram(aes(
    y = ..density.., 
    fill = propertyType, 
    color = propertyType
  ), 
  alpha = 0.3, position = "identity") + 
  geom_density(aes(color = propertyType), size = 0.7)
```
We have two group of postcode. But neither match with a propertyType. It could be interesting to create a categorical feature for the postcode and check if they are a place where the price is higher. It can be interpreted like neighbourhoods.

```{r}
#Create a categorical feature
df <- df %>% mutate(postcode = case_when(postcode > 2800 ~ "pc29",
                                         TRUE ~ "pc26"))

#Convert type
df[, "postcode"] <- as.factor(df[, "postcode"])
```

Now we can visualize price per propertyType and postcode. 

```{r}
#Price boxplot
ggplot(data = df, aes(x = propertyType, y = price)) + geom_boxplot(aes(color = postcode))
```


```{r}
#Remove outliers (price higher than 2 000 000$)
df <- df %>% filter(price < 2e+06)

#Plot again price boxplot
ggplot(data = df, aes(x = propertyType, y = price)) + geom_boxplot(aes(color = postcode))
```

It seems that property with postcode start with 26 are little more expensive than the others, but it still have an overlap between the two neighbourhoods.

Another interesting graphic is price against number of bedrooms. 

```{r}
#Price against bedrooms
ggplot(df, aes(x = factor(bedrooms), y = price)) + 
  geom_boxplot(alpha = 0.3) +
  labs(x = "number of bedrooms")
```

Another important graphic is the correlation heatmap. It shows the correlation between features, i.e. we need to test price and bedrooms relationship with each other.


```{r}
#Create a correlation matrix
corr_df <- df %>% select(c("price", "bedrooms")) %>% cor()
corr_df
```


```{r}
#Create month and year columns
df$year <- year(df$datesold)
df$month <- month(df$datesold, label = TRUE)

#Plot all sells per month and year
ggplot(df, aes(x = month, y = price)) +
  geom_point(aes(color = factor(year))) + 
  facet_wrap(~year) +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_color_discrete(name = "year")
```
```{r}
#Reshape data by year and month and calculate the price average
df_time <- df %>% group_by(year, month) %>% summarize(medPrice = median(price))

#Plot price evolution per month
ggplot(df_time, aes(x = month, y = medPrice)) +
  geom_line(aes(color = factor(year), group = year)) +
  scale_color_discrete(name = "year")
  
```


```{r}
#Reshape data by year
df_time <- df %>% group_by(year, postcode) %>% summarize(medPrice = median(price))

ggplot(df_time, aes(x = year, y = medPrice)) +
  geom_line(aes(color = postcode))
```

### Modeling 

We will define a linear model to predict the price with other features.

```{r}
#Define a function for train and test split
train_test_split <- function(data, train_size = 0.7) {
  set.seed(123)
  #Define the train size
  smp_size <- floor(train_size * nrow(data))
  #Define train index
  train_idx <- sample(seq_len(nrow(data)), size = smp_size)
  
  train <- data[train_idx,]
  test <- data[-train_idx,]
  
  return(list("train" = train, "test" = test))
}

#Split the data into train and test set
split <- train_test_split(df)
train <- split$train
test <- split$test

#Fit the linear regression
model1 <- lm(price ~ datesold + postcode + bedrooms + propertyType,
             data = train)
```

Now our linear regression are fit. We can use the summary function to print out information about the models.



```{r}
#Visualize model coefficient
coefplot(model1)
```

